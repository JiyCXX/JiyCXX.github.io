<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RocketMQ 应用 | JiyCXX</title><meta name="keywords" content="RocketMQ MQ"><meta name="author" content="JiyCXX"><meta name="copyright" content="JiyCXX"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RocketMQ 笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ 应用">
<meta property="og:url" content="https://jiycxx.github.io/2019/01/18/RocketMQ4/index.html">
<meta property="og:site_name" content="JiyCXX">
<meta property="og:description" content="RocketMQ 笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiycxx.github.io/img/background/RocketMQ.jpg">
<meta property="article:published_time" content="2019-01-18T06:00:00.000Z">
<meta property="article:modified_time" content="2022-01-29T07:01:26.972Z">
<meta property="article:author" content="JiyCXX">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="RocketMQ">
<meta property="article:tag" content="MQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiycxx.github.io/img/background/RocketMQ.jpg"><link rel="shortcut icon" href="/img/icon/favicon.png"><link rel="canonical" href="https://jiycxx.github.io/2019/01/18/RocketMQ4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RocketMQ 应用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-29 15:01:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/js/custom.js" ><link rel="stylesheet" href="/js/custom.css" ><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js"></script><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,300&display=swap" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-file-alt"></i><span> 博客目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 所有标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-chart-bar"></i><span> 文章统计</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> JiyCXX</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background/RocketMQ.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/" title="������ҳ"><span>JiyCXX</span><i class="fas fa-home"></i></a></span><span id="page_name"><a id="page-name-text"></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-file-alt"></i><span> 博客目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 所有标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-chart-bar"></i><span> 文章统计</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> JiyCXX</span></a></div></div></div><div id="hotkey"><div id="search-button"><a class="site-page social-icon search" title="搜索"><i class="fas fa-search fa-fw"></i></a></div><div id="mode-button"><a class="site-page" title="浅色和深色模式转换"><i class="fas fa-adjust fa-fw"></i></a></div><div id="top-button"><a class="site-page" title="回到顶部"><i class="fas fa-rocket fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RocketMQ 应用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-01-18T06:00:00.000Z" title="发表于 2019-01-18 14:00:00">2019-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-29T07:01:26.972Z" title="更新于 2022-01-29 15:01:26">2022-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RocketMQ-MQ/">RocketMQ  MQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RocketMQ 应用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第-4-章-RocketMQ应用"><a href="#第-4-章-RocketMQ应用" class="headerlink" title="第 4 章 RocketMQ应用"></a>第 4 章 RocketMQ应用</h2><h2 id="一、普通消息"><a href="#一、普通消息" class="headerlink" title="一、普通消息"></a>一、普通消息</h2><h3 id="1-消息发送分类"><a href="#1-消息发送分类" class="headerlink" title="1 消息发送分类"></a>1 消息发送分类</h3><p>Producer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。</p>
<ul>
<li>同步发送消息</li>
</ul>
<p>同步发送消息是指，Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ52.png" alt="分布式消息队列RocketMQ52.png"></p>
<ul>
<li>异步发送消息</li>
</ul>
<p>异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ53.png" alt="分布式消息队列RocketMQ53.png"></p>
<ul>
<li>单向发送消息</li>
</ul>
<p>单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ54.png" alt="分布式消息队列RocketMQ54.png"></p>
<h3 id="2-代码举例"><a href="#2-代码举例" class="headerlink" title="2 代码举例"></a>2 代码举例</h3><ul>
<li>创建工程</li>
</ul>
<p>创建一个Maven的Java工程<strong>rocketmq-test</strong>。</p>
<ul>
<li>导入依赖</li>
</ul>
<p>导入rocketmq的client依赖。注意直接RocketMQ的使用版本,要个服务器上版本统一。<br>使用之前保证MQ服务启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;<span class="number">1.8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--需要与RocketMQ版本相同--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.8</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义同步消息发送生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个producer，参数为Producer Group名称</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定nameServer地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置当发送失败时重试发送的次数，默认为2次</span></span><br><span class="line">        producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 设置发送超时时限为5s，默认3s</span></span><br><span class="line">        producer.setSendMsgTimeout(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 开启生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 生产并发送100条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 为消息指定key</span></span><br><span class="line">            msg.setKeys(<span class="string">&quot;key-&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>消息发送的状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息发送的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SendStatus</span> </span>&#123;</span><br><span class="line">    SEND_OK,       <span class="comment">// 发送成功</span></span><br><span class="line">    FLUSH_DISK_TIMEOUT,  <span class="comment">// 刷盘超时。当Broker设置的刷盘策略为同步刷盘时才可能出现这种异常状态。异步刷盘不会出现</span></span><br><span class="line">    FLUSH_SLAVE_TIMEOUT, <span class="comment">// Slave同步超时。当Broker集群设置的Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span></span><br><span class="line">    SLAVE_NOT_AVAILABLE, <span class="comment">// 没有可用的Slave。当Broker集群设置为Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义异步消息发送生产者</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定异步发送失败后不进行重试发送</span></span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 指定新创建的Topic的Queue数量为2，默认为4</span></span><br><span class="line">        producer.setDefaultTopicQueueNums(<span class="number">2</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;myTopicA&quot;</span>, <span class="string">&quot;myTag&quot;</span>, body);</span><br><span class="line">                <span class="comment">// 异步发送。指定回调</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="comment">// 当producer接收到MQ发送来的ACK后就会触发该回调方法的执行</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.println(sendResult);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end-for</span></span><br><span class="line">        <span class="comment">// sleep一会儿</span></span><br><span class="line">        <span class="comment">// 由于采用的是异步发送，所以若这里不sleep，</span></span><br><span class="line">        <span class="comment">// 则消息还未发送就会将producer给关闭，报错</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义单向消息发送生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;single&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 单向发送</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;producer shutdown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义消息消费者</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个pull消费者</span></span><br><span class="line">        <span class="comment">// DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(&quot;cg&quot;);</span></span><br><span class="line">        <span class="comment">// 定义一个push消费者</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定nameServer</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定从第一条消息开始消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 指定消费topic与tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定采用“广播模式”进行消费，默认为“集群模式”</span></span><br><span class="line">        <span class="comment">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class="line">        <span class="comment">// 注册消息监听器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="comment">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span></span><br><span class="line">            <span class="comment">// 其返回值为当前consumer消费的状态</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span></span><br><span class="line"><span class="function">                <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 逐条消费消息</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回消费状态：消费成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 开启消费者消费</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、顺序消息"><a href="#二、顺序消息" class="headerlink" title="二、顺序消息"></a>二、顺序消息</h2><h3 id="1-什么是顺序消息"><a href="#1-什么是顺序消息" class="headerlink" title="1 什么是顺序消息"></a>1 什么是顺序消息</h3><p>顺序消息指的是，严格按照消息的<strong>发送顺序</strong>进行<strong>消费</strong>的消息(FIFO)。</p>
<p>默认情况下生产者会把消息以<strong>Round Robin</strong>轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。</p>
<hr>
<h3 id="2-为什么需要顺序消息"><a href="#2-为什么需要顺序消息" class="headerlink" title="2 为什么需要顺序消息"></a>2 为什么需要顺序消息</h3><p>例如，现在有<strong>TOPIC ORDER_STATUS (订单状态)</strong>,其下有4个Queue队列，该Topic中的不同消息用于描述当前订单的不同状态。假设订单有状态：<strong>未支付、已支付、发货中、发货成功、发货失败</strong>。</p>
<p>根据以上订单状态，生产者从<strong>时序</strong>上可以生成如下几个消息：</p>
<p><strong>订单T0000001:未支付 –&gt; 订单T0000001:已支付 –&gt; 订单T0000001:发货中 –&gt; 订单T0000001:发货失败</strong><br>消息发送到MQ中之后，Queue的选择如果采用轮询策略，消息在MQ的存储可能如下：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ55.png" alt="分布式消息队列RocketMQ55.png"></p>
<p>这种情况下，我们希望Consumer消费消息的顺序和我们发送是一致的，然而上述MQ的投递和消费方式，我们无法保证顺序是正确的。对于顺序异常的消息，Consumer即使设置有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ56.png" alt="分布式消息队列RocketMQ56.png"></p>
<p>基于上述的情况，可以设计如下方案：对于<strong>相同订单号</strong>的消息，通过<strong>一定的策略</strong>，将其放置在<strong>一个Queue中</strong>，然后<strong>消费者再采用一定的策略</strong>（例如，一个线程独立处理一个queue，保证处理消息的顺序性），能够保证消费的<strong>顺序性</strong>。</p>
<h3 id="3-有序性分类"><a href="#3-有序性分类" class="headerlink" title="3 有序性分类"></a>3 有序性分类</h3><p>根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：<strong>分区有序</strong>与<strong>全局有序</strong>。</p>
<ul>
<li>全局有序<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ57.png" alt="分布式消息队列RocketMQ57.png"></li>
</ul>
<p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序， 称为<strong>全局有序</strong>。</p>
<blockquote>
<p>在创建Topic时指定Queue的数量。有三种指定方式：<br>1 ）在代码中创建Producer时，可以指定其自动创建的Topic的Queue数量<br>2 ）在RocketMQ可视化控制台中手动创建Topic时指定Queue数量<br>3 ）使用mqadmin命令手动创建Topic时指定Queue数量</p>
</blockquote>
<ul>
<li>分区有序<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ58.png" alt="分布式消息队列RocketMQ58.png"></li>
</ul>
<p>如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为<strong>分区有序</strong>。</p>
<blockquote>
<p>如何实现Queue的选择？</p>
</blockquote>
<blockquote>
<p>在定义Producer时我们可以指定<strong>消息队列选择器</strong>，而这个选择器是我们</p>
</blockquote>
<blockquote>
<p>自己实现了MessageQueueSelector接口定义的。在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都<strong>不能重复，都是唯一的</strong>。</p>
</blockquote>
<blockquote>
<p>一般性的选择算法是，让选择key（或其hash值）与该Topic所包含的Queue的<strong>数量取模</strong>，其结果即为选择出的Queue的QueueId。</p>
</blockquote>
<blockquote>
<p>取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consuemr可能会消费到不同选择key的消息。</p>
</blockquote>
<blockquote>
<p>这个问题如何解决？<br>一般性的作法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。</p>
</blockquote>
<blockquote>
<p>以上做法会不会出现如下新的问题呢？<br>不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费现一个Queue的不同选择key的消息的Consumer一定属于不同的Group。而不同的Group中的Consumer间的消费是相互隔离的，互不影响的。</p>
</blockquote>
<hr>
<h3 id="4-代码举例"><a href="#4-代码举例" class="headerlink" title="4 代码举例"></a>4 代码举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Integer orderId = i;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicA&quot;</span>, <span class="string">&quot;TagA&quot;</span>, body);</span><br><span class="line">            SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs,Message msg, Object arg)</span></span>&#123;</span><br><span class="line">                    Integer id = (Integer) arg;</span><br><span class="line">                    <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                    <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, orderId);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、延时消息"><a href="#三、延时消息" class="headerlink" title="三、延时消息"></a>三、延时消息</h2><h3 id="1-什么是延时消息"><a href="#1-什么是延时消息" class="headerlink" title="1 什么是延时消息"></a>1 什么是延时消息</h3><p>当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为<strong>延时消息</strong>。</p>
<p>采用RocketMQ的延时消息可以实现<strong>定时任务</strong>的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景， 12306 平台订票超时未支付取消订票的场景。</p>
<blockquote>
<p>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。<br>在 12306 平台中，车票预订成功后就会发送一条延迟消息。这条消息将会在 45 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消预订，将车票再次放回到票池；如果完成支付，则忽略。</p>
</blockquote>
<hr>
<h3 id="2-延时等级"><a href="#2-延时等级" class="headerlink" title="2 延时等级"></a>2 延时等级</h3><p>延时消息的延迟时长<strong>不支持随意时长的延迟</strong>，是通过特定的延迟等级来指定的。延时等级定义在<strong>RocketMQ服务端</strong>的<strong>MessageStoreConfig类</strong>中的如下变量中：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ59.png" alt="分布式消息队列RocketMQ59.png"></p>
<p>即，若指定的延时等级为 3 ，则表示延迟时长为10s，即延迟等级是从 1 开始计数的。</p>
<p>当然，如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h <span class="number">1d</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-延时消息实现原理"><a href="#3-延时消息实现原理" class="headerlink" title="3 延时消息实现原理"></a>3 延时消息实现原理</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ60.png" alt="分布式消息队列RocketMQ60.png"></p>
<p>具体实现方案是：</p>
<ul>
<li>修改消息<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ61.png" alt="分布式消息队列RocketMQ61.png"></li>
</ul>
<p>Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p>
<ul>
<li>修改消息的Topic为SCHEDULE_TOPIC_XXXX</li>
<li>根据延时等级，在consumequeue目录中SCHEDULE-TOPIC-XX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）。</li>
</ul>
<blockquote>
<p><strong>延迟等级delayLevel与queueId的对应关系为queueId = delayLevel -1</strong><br>需要注意，在创建queueId目录时，并<strong>不是一次性地将所有延迟等级对应的目录全部创建完毕</strong>，而是<strong>用到哪个延迟等级创建哪个目录</strong>.<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ62.png" alt="分布式消息队列RocketMQ62.png"></p>
</blockquote>
<ul>
<li><p>修改消息索引单元内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的投递时间。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。投递时间=消息存储时间+延时等级时间。消息存储时间指的是消息被发送到Broker时的时间戳。</p>
</li>
<li><p>将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中</p>
</li>
</ul>
<blockquote>
<p>SCHEDULE_TOPIC_XXXX目录中各个延时等级Queue中的消息是如何排序的？<br>是按照<strong>消息投递时间排序</strong>的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC_XXXX目录下相同Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于消息存储时间了。即按照消息被发送到Broker的时间进行排序的。</p>
</blockquote>
<ul>
<li>投递延时消息</li>
</ul>
<p>Broker内部有一个<strong>延迟消息服务类ScheuleMessageService</strong>，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到目标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，<strong>并将其原来的延时等级设置为 0</strong> ，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。</p>
<blockquote>
<p>ScheuleMessageService在Broker启动时，会创建并启动一个定时器TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimerTask负责一个延迟等级消息的消费与投递。每个TimerTask都会检测相应Queue队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（<strong>消息是按照投递时间排序的</strong>）；若第一条消息到期了，则将该消息投递到目标Topic，即消费该消息。</p>
</blockquote>
<ul>
<li>将消息重新写入commitlog</li>
</ul>
<p>延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p>
<blockquote>
<p>这其实就是一次普通消息发送。只不过这次的消息Producer是延迟消息服务类ScheuleMessageService。</p>
</blockquote>
<h3 id="4-代码举例-1"><a href="#4-代码举例-1" class="headerlink" title="4 代码举例"></a>4 代码举例</h3><ul>
<li>定义DelayProducer类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicB&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 指定消息延迟等级为3级，即延迟10s</span></span><br><span class="line">            <span class="comment">// msg.setDelayTimeLevel(3);</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            <span class="comment">// 输出消息被发送的时间</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            System.out.println(<span class="string">&quot; ,&quot;</span> + sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义OtherConsumer类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQPushConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">                                    );</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicB&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span></span><br><span class="line"><span class="function">                <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="comment">// 输出消息被消费的时间</span></span><br><span class="line">                    System.out.print(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                    System.out.println(<span class="string">&quot; ,&quot;</span> + msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、事务消息"><a href="#四、事务消息" class="headerlink" title="四、事务消息"></a>四、事务消息</h2><h3 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1 问题引入"></a>1 问题引入</h3><p>这里的一个需求场景是：工行用户A向建行用户B转账 1 万元。</p>
<p>我们可以使用同步消息来处理该需求场景：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ63.png" alt="分布式消息队列RocketMQ63.png"></p>
<ol>
<li>工行系统发送一个给B增款 1 万元的同步消息M给Broker</li>
<li>消息被Broker成功接收后，向工行系统发送成功ACK</li>
<li>工行系统收到成功ACK后从用户A中扣款 1 万元</li>
<li>建行系统从Broker中获取到消息M</li>
<li>建行系统消费消息M，即向用户B中增加 1 万元</li>
</ol>
<blockquote>
<p>这其中是有问题的：若第 3步中的扣款操作失败，但消息已经成功发送到了Broker。对于MQ来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户B增加了 1 万元。出现了数据不一致问题。</p>
</blockquote>
<hr>
<h3 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2 解决思路"></a>2 解决思路</h3><p>解决思路是，让第 1 、 2 、 3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用<strong>事务消息</strong>。这里要使用分布<strong>式事务解决方案</strong>。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ64.png" alt="分布式消息队列RocketMQ64.png"></p>
<p>使用事务消息来处理该需求场景：</p>
<ol>
<li><p>事务管理器TM向事务协调器TC发起指令，开启全局事务</p>
</li>
<li><p>工行系统发一个给B增款 1 万元的事务消息M给TC</p>
</li>
<li><p>TC会向Broker发送半事务消息prepareHalf，将消息M预提交到Broker。此时的建行系统是看不到Broker中的消息M的</p>
</li>
<li><p>Broker会将预提交执行结果Report给TC。</p>
</li>
<li><p>如果预提交失败，则TC会向TM上报预提交失败的响应，全局事务结束；如果预提交成功，TC会调用工行系统的回调操作，去完成工行用户A的预扣款1万元的操作</p>
</li>
<li><p>工行系统会向TC发送预扣款执行结果，即本地事务的执行状态</p>
</li>
<li><p>TC收到预扣款执行结果后，会将结果上报给TM。</p>
</li>
</ol>
<blockquote>
<p>预扣款执行结果存在三种可能性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 描述本地事务执行状态</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LocalTransactionState</span> </span>&#123;</span><br><span class="line">  COMMIT_MESSAGE,  <span class="comment">// 本地事务执行成功</span></span><br><span class="line">  ROLLBACK_MESSAGE,  <span class="comment">// 本地事务执行失败</span></span><br><span class="line">  UNKNOW,  <span class="comment">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="8">
<li><p>TM会根据上报结果向TC发出不同的确认指令</p>
</li>
<li><p>若预扣款成功（本地事务状态为COMMIT_MESSAGE），则TM向TC发送Global Commit指令</p>
</li>
<li><p>若预扣款失败（本地事务状态为ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令</p>
</li>
<li><p>若现未知状态（本地事务状态为UNKNOW），则会触发工行系统的本地事务状态<strong>回查操作</strong>。回查操作会将回查结果，即COMMITMESSAGE或ROLLBACK_MESSAGE Report给TC。TC将结果上报给TM，TM会再向TC发送最终确认指令Global Commit或Global Rollback</p>
</li>
<li><p>TC在接收到指令后会向Broker与工行系统发出确认指令</p>
</li>
</ol>
<p>TC接收的若是Global Commit指令，则向Broker与工行系统发送Branch Commit指令。此时Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认TC接收到的若是Global Rollback指令，则向Broker与工行系统发送Branch Rollback指令。此时Broker中的消息M将被撤销；工行用户A中的扣款操作将被回滚</p>
<blockquote>
<p>以上方案就是为了确保消息投递与扣款操作能够在一个事务中，要成功都成功，有一个失败，<br>则全部回滚。<br>以上方案并不是一个典型的XA模式。<br>因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>
</blockquote>
<h3 id="3-基础"><a href="#3-基础" class="headerlink" title="3 基础"></a>3 基础</h3><ul>
<li>分布式事务</li>
</ul>
<p>对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。</p>
<ul>
<li>事务消息</li>
</ul>
<p>RocketMQ提供了类似XOpenXA的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA是一种分布式事务解决方案，一种分布式事务处理模式。</p>
<ul>
<li>半事务消息</li>
</ul>
<p>暂不能投递的消息，发送方已经成功地将消息发送到了Broker，但是Broker未收到最终确认指令，此时该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。</p>
<ul>
<li>本地事务状态</li>
</ul>
<p>Producer<strong>回调操作执行</strong>的结果为本地事务状态，其会发送给TC，而TC会再发送给TM。TM会根据TC发送来的本地事务状态来决定全局事务确认指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 描述本地事务执行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LocalTransactionState</span> </span>&#123;</span><br><span class="line">    COMMIT_MESSAGE,  <span class="comment">// 本地事务执行成功</span></span><br><span class="line">    ROLLBACK_MESSAGE,  <span class="comment">// 本地事务执行失败</span></span><br><span class="line">    UNKNOW,  <span class="comment">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息回查<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ65.png" alt="分布式消息队列RocketMQ65.png"></li>
</ul>
<p>消息回查，即重新查询本地事务的执行状态。本例就是重新到DB中查看预扣款操作是否执行成功。</p>
<blockquote>
<p>注意，<strong>消息回查不是重新执行回调操作</strong>。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。</p>
</blockquote>
<blockquote>
<p>引发消息回查的原因最常见的有两个：<br>1)回调操作返回UNKNWON<br>2)TC没有接收到TM的最终全局事务确认指令</p>
</blockquote>
<ul>
<li>RocketMQ中的消息回查设置</li>
</ul>
<p>关于消息回查，有三个常见的属性设置。它们都在broker加载的配置文件中设置，例如：</p>
<ul>
<li>transactionTimeout=20，指定TM在 20 秒内应将最终确认状态发送给TC，否则引发消息回查。默认为 60 秒</li>
<li>transactionCheckMax=5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。</li>
<li>transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。</li>
</ul>
<hr>
<h3 id="4-XA模式三剑客"><a href="#4-XA模式三剑客" class="headerlink" title="4 XA模式三剑客"></a>4 XA模式三剑客</h3><ul>
<li>XA协议</li>
</ul>
<p>XA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于XA协议的。XA协议由Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的Unix事务系统）首先提出的，并交给X/Open组织，作为资源管理器与事务管理器的接口标准。</p>
<ul>
<li><p>XA模式中有三个重要组件：TC、TM、RM。</p>
</li>
<li><p>TC</p>
</li>
</ul>
<p>Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<blockquote>
<p>RocketMQ中Broker充当着TC。</p>
</blockquote>
<ul>
<li>TM</li>
</ul>
<p>Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。</p>
<blockquote>
<p>RocketMQ中事务消息的Producer充当着TM。</p>
</blockquote>
<ul>
<li>RM</li>
</ul>
<p>Resource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<blockquote>
<p>RocketMQ中事务消息的Producer及Broker均是RM。</p>
</blockquote>
<hr>
<h3 id="5-XA模式架构"><a href="#5-XA模式架构" class="headerlink" title="5 XA模式架构"></a>5 XA模式架构</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ66.png" alt="分布式消息队列RocketMQ66.png"></p>
<p>XA模式是一个典型的2PC，其执行原理如下：</p>
<ol>
<li>TM向TC发起指令，开启一个全局事务。</li>
<li>根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。</li>
<li>各个RM在接收到指令后会在进行本地事务预执行。</li>
<li>RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。</li>
<li>TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。</li>
<li>若所有结果都是成功响应，则向TC发送GlobalCommit指令。</li>
<li>只要有结果是失败响应，则向TC发送Global Rollback指令。</li>
<li>TC在接收到指令后再次向RM发送确认指令。</li>
</ol>
<p>事务消息方案并不是一个典型的XA模式。因为<strong>XA模式中的分支事务是异步的</strong>，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>
<hr>
<h3 id="6-注意"><a href="#6-注意" class="headerlink" title="6 注意"></a>6 注意</h3><ul>
<li><p><strong>事务消息不支持延时消息</strong></p>
</li>
<li><p>对于事务消息要做<strong>好幂等性检查</strong>，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）</p>
</li>
</ul>
<hr>
<h3 id="7-代码举例"><a href="#7-代码举例" class="headerlink" title="7 代码举例"></a>7 代码举例</h3><ul>
<li><p>定义工行事务监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ICBCTransactionListener</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 回调操作方法</span></span><br><span class="line">    <span class="comment">// 消息预提交成功就会触发该方法的执行，用于完成本地事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg,Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;预提交消息成功：&quot;</span> + msg);</span><br><span class="line">        <span class="comment">// 假设接收到TAGA的消息就表示扣款操作成功，TAGB的消息表示扣款失败，</span></span><br><span class="line">        <span class="comment">// TAGC表示扣款结果不清楚，需要执行消息回查</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGA&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGB&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGC&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消息回查方法</span></span><br><span class="line">    <span class="comment">// 引发消息回查的原因最常见的有两个：</span></span><br><span class="line">    <span class="comment">// 1)回调操作返回UNKNWON</span></span><br><span class="line">    <span class="comment">// 2)TC没有接收到TM的最终全局事务确认指令</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行消息回查&quot;</span> + msg.getTags());</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义事物消息生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            TransactionMQProducer(<span class="string">&quot;tpg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义一个线程池</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> corePoolSize 线程池中核心线程数量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> maximumPoolSize 线程池中最多线程数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量</span></span><br><span class="line"><span class="comment">是，</span></span><br><span class="line"><span class="comment">*           多余空闲线程的存活时长</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> workQueue 临时存放任务的队列，其参数就是队列的长度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>,<span class="number">100</span>, TimeUnit.SECONDS,<span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>),<span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 为生产者指定一个线程池</span></span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        <span class="comment">// 为生产者添加事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> ICBCTransactionListener());</span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = &#123;<span class="string">&quot;TAGA&quot;</span>,<span class="string">&quot;TAGB&quot;</span>,<span class="string">&quot;TAGC&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TTopic&quot;</span>, tags[i], body);</span><br><span class="line">            <span class="comment">// 发送事务消息</span></span><br><span class="line">            <span class="comment">// 第二个参数用于指定在执行本地事务时要使用的业务参数</span></span><br><span class="line">            SendResult sendResult =</span><br><span class="line">                producer.sendMessageInTransaction(msg,<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果为：&quot;</span> +</span><br><span class="line">                               sendResult.getSendStatus());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义消费者</p>
</li>
</ul>
<p>直接使用普通消息的SomeConsumer作为消费者即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个pull消费者</span></span><br><span class="line">        <span class="comment">// DefaultLitePullConsumer consumer = new</span></span><br><span class="line">        DefaultLitePullConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义一个push消费者</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQPushConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定nameServer</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定从第一条消息开始消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 指定消费topic与tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定采用“广播模式”进行消费，默认为“集群模式”</span></span><br><span class="line">        <span class="comment">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class="line">        <span class="comment">// 注册消息监听器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;               </span><br><span class="line">            <span class="comment">// 一旦broker中有了其订阅的消息就会触发该方法的执行，                        </span></span><br><span class="line">            <span class="comment">// 其返回值为当前consumer消费的状态</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span></span><br><span class="line"><span class="function">                <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 逐条消费消息</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回消费状态：消费成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 开启消费者消费</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、批量消息"><a href="#五、批量消息" class="headerlink" title="五、批量消息"></a>五、批量消息</h2><h3 id="1-批量发送消息"><a href="#1-批量发送消息" class="headerlink" title="1 批量发送消息"></a>1 批量发送消息</h3><ul>
<li>发送限制</li>
</ul>
<p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以<br>下几点：</p>
<ul>
<li><p>批量发送的消息必须具有<strong>相同的Topic</strong></p>
</li>
<li><p>批量发送的消息必须具有<strong>相同的刷盘策略</strong></p>
</li>
<li><p>批量发送的消息<strong>不能是延时消息与事务消息</strong></p>
</li>
<li><p>批量发送大小<br>默认情况下，<strong>一批发送的消息总大小不能超过4MB字节</strong>。如果想超出该值，有两种解决方案：</p>
</li>
<li><p>方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送</p>
</li>
<li><p>方案二：在Producer端与Broker端修改属性</p>
</li>
</ul>
<blockquote>
<p>Producer端需要在发送之前设置Producer的maxMessageSize属性<br>Broker端需要修改其加载的配置文件中的maxMessageSize属性</p>
</blockquote>
<ul>
<li>生产者发送的消息大小<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ67.png" alt="分布式消息队列RocketMQ67.png"></li>
</ul>
<p>生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。</p>
<p>这个字符串由四部分构成：Topic、消息Body、消息日志<strong>占20字节</strong>，及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p>
<h3 id="2-批量消费消息"><a href="#2-批量消费消息" class="headerlink" title="2 批量消费消息"></a>2 批量消费消息</h3><ul>
<li>修改批量属性<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ68.png" alt="分布式消息队列RocketMQ68.png"></li>
</ul>
<p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的<strong>consumeMessageBatchMaxSize属性来指定</strong>。不过该值不能超过32。因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改Consumer的<strong>pullBatchSize</strong>属性来指定。</p>
<ul>
<li><p>存在的问题<br>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置的越大越好？当然不是。</p>
</li>
<li><p><strong>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长</strong>，且在网络上传输出现问题的可能性就越高。若<strong>在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取</strong>。</p>
</li>
<li><p><strong>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低</strong>，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在<strong>处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理</strong>。</p>
</li>
</ul>
<h3 id="3-代码举例"><a href="#3-代码举例" class="headerlink" title="3 代码举例"></a>3 代码举例</h3><p>该批量发送的需求是，不修改最大发送4M的默认值，但要防止发送的批量消息超出4M的限制。</p>
<ul>
<li>定义消息列表分割器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息列表分割器：其只会处理每条消息的大小不超4M的情况。</span></span><br><span class="line"><span class="comment">// 若存在某条消息，其本身大小大于4M，这个分割器无法处理，</span></span><br><span class="line"><span class="comment">// 其直接将这条消息构成一个子列表返回。并没有再进行分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定极限值为4M</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_LIMIT =  <span class="number">4</span> *<span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存放所有要发送的消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要进行批量发送消息的小集合起始索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前开始遍历的消息索引要小于消息总数</span></span><br><span class="line">        <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Message&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex = currIndex;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录当前要发送的这一小批次消息列表的大小</span></span><br><span class="line">        <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前遍历的消息</span></span><br><span class="line">            Message message = messages.get(nextIndex);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 统计当前遍历的message的大小</span></span><br><span class="line">            <span class="keyword">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class="line">            Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry :</span><br><span class="line">                 properties.entrySet()) &#123;</span><br><span class="line">                tmpSize += entry.getKey().length() +</span><br><span class="line">                    entry.getValue().length();</span><br><span class="line">            &#125;</span><br><span class="line">            tmpSize = tmpSize + <span class="number">20</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断当前消息本身是否大于4M</span></span><br><span class="line">            <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    nextIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalSize += tmpSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end-for</span></span><br><span class="line">        <span class="comment">// 获取当前messages列表的子集合[currIndex, nextIndex)</span></span><br><span class="line">        List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">        <span class="comment">// 下次遍历的开始索引</span></span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="定义批量消息生产者"><a href="#定义批量消息生产者" class="headerlink" title="定义批量消息生产者"></a>定义批量消息生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定要发送的消息的最大大小，默认是4M</span></span><br><span class="line">        <span class="comment">// 不过，仅修改该属性是不行的，还需要同时修改broker加载的配置文件中的</span></span><br><span class="line">        <span class="comment">// maxMessageSize属性</span></span><br><span class="line">        <span class="comment">// producer.setMaxMessageSize(8 * 1024 * 1024);</span></span><br><span class="line">        producer.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义要发送的消息集合</span></span><br><span class="line">        List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">            messages.add(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义消息列表分割器，将消息列表分割为多个不超出4M大小的小列表</span></span><br><span class="line">        MessageListSplitter splitter = <span class="keyword">new</span> MessageListSplitter(messages);</span><br><span class="line">        <span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;Message&gt;  listItem = splitter.next();</span><br><span class="line">                producer.send(listItem);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义批量消息消费者"><a href="#定义批量消息消费者" class="headerlink" title="定义批量消息消费者"></a>定义批量消息消费者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQPushConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">                                    );</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;someTopicA&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定每次可以消费10条消息，默认为1</span></span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 指定每次可以从Broker拉取40条消息，默认为32</span></span><br><span class="line">        consumer.setPullBatchSize(<span class="number">40</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消费成功的返回结果</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                <span class="comment">// 消费异常时的返回结果</span></span><br><span class="line">                <span class="comment">// return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、消息过滤"><a href="#六、消息过滤" class="headerlink" title="六、消息过滤"></a>六、消息过滤</h2><p>消息者在进行消息订阅时，除了可以指定要订阅消息的Topic外，还可以对指定Topic中的消息根据指定条件进行过滤，即可以订阅比Topic更加细粒度的消息类型。</p>
<p>对于指定Topic消息的过滤有两种过滤方式：<strong>Tag过滤</strong>与<strong>SQL过滤</strong>。</p>
<h3 id="1-Tag过滤"><a href="#1-Tag过滤" class="headerlink" title="1 Tag过滤"></a>1 Tag过滤</h3><p>通过consumer的subscribe()方法指定要订阅消息的Tag。如果订阅多个Tag的消息，Tag间使用或运算<br>符(双竖线||)连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">DefaultMQPushConsumer(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-SQL过滤"><a href="#2-SQL过滤" class="headerlink" title="2 SQL过滤"></a>2 SQL过滤</h3><p>SQL过滤是一种通过特定表达式对事先埋入到消息中的<strong>用户属性</strong>进行筛选过滤的方式。通过SQL过滤，可以实现对消息的复杂过滤。不过，只有使用<strong>PUSH模式</strong>的消费者才能使用SQL过滤。SQL过滤表达式中支持多种常量类型与运算符。</p>
<ul>
<li><p>支持的常量类型：</p>
</li>
<li><p>数值：比如： 123 ，3.1415</p>
</li>
<li><p>字符：必须用单引号包裹起来，比如：’abc’</p>
</li>
<li><p>布尔：TRUE 或 FALSE</p>
</li>
<li><p>NULL：特殊的常量，表示空</p>
</li>
<li><p>支持的运算符有：</p>
</li>
<li><p>数值比较：&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=</p>
</li>
<li><p>字符比较：=，&lt;&gt;，IN</p>
</li>
<li><p>逻辑运算 ：AND，OR，NOT</p>
</li>
<li><p>NULL判断：IS NULL 或者 IS NOT NULL</p>
</li>
</ul>
<p><strong>默认情况下Broker没有开启消息的SQL过滤功能</strong>，需要在Broker加载的配置文件中添加如下属性，以开启该功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">enablePropertyFilter = <span class="keyword">true</span> </span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/34de12ae87aa4b6b99f12a782b2265a4.png" alt="34de12ae87aa4b6b99f12a782b2265a4.png"></p>
<p>在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是conf/broker.conf，启动时使用如下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sh bin/mqbroker -n localhost:<span class="number">9876</span> -c conf/broker.conf &amp;   #指定配置文件</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-代码举例-1"><a href="#3-代码举例-1" class="headerlink" title="3 代码举例"></a>3 代码举例</h3><ul>
<li>定义Tag过滤Producer</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByTagProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        producer.start();  </span><br><span class="line">        <span class="comment">//均包含下面Tag，为下面3种，生成了下面3种</span></span><br><span class="line">        String[] tags = &#123;<span class="string">&quot;myTagA&quot;</span>,<span class="string">&quot;myTagB&quot;</span>,<span class="string">&quot;myTagC&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">            String tag =  tags[i%tags.length];</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;myTopic&quot;</span>,tag,body);</span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义Tag过滤Consumer<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByTagConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQPushConsumer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">//仅订阅myTagA、myTagB的消息中的一个，或者myTopic，不包含上面生产者的myTagC</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;myTagA || myTagB&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span></span><br><span class="line"><span class="function">                <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt me:msgs)&#123;</span><br><span class="line">                    System.out.println(me);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>定义SQL过滤Producer</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterBySQLProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;myTag&quot;</span>, body);</span><br><span class="line">                <span class="comment">//事先埋入用户属性age；K-V形式</span></span><br><span class="line">                msg.putUserProperty(<span class="string">&quot;age&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义SQL过滤Consumer</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterBySQLConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">//订阅myTopic的Tag，且对应消息中的用户属性age，在0到6之间</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;myTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;age between 0 and 6&quot;</span>));</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span></span><br><span class="line"><span class="function">                <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt me:msgs)&#123;</span><br><span class="line">                    System.out.println(me);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、消息发送重试机制"><a href="#七、消息发送重试机制" class="headerlink" title="七、消息发送重试机制"></a>七、消息发送重试机制</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><p>Producer对发送失败的消息进行重新发送的机制，称为<strong>消息发送重试机制</strong>，也称为消息重投机制。</p>
<p>对于消息重投，需要注意以下几点：</p>
<ul>
<li><p>生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式发送失败是没有重试机制的</p>
</li>
<li><p>只有普通消息具有发送重试机制，顺序消息是没有的消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在RocketMQ中是无法避免的问题</p>
</li>
<li><p>消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件producer主动重发、consumer负载变化（发生Rebalance，不会导致消息重复，但可能出现重复消费）也会导致重复消息</p>
</li>
<li><p>消息重复无法避免，但要避免消息的重复消费。</p>
</li>
<li><p>避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息key），使消费者对消息进行消费判断来避免重复消费</p>
</li>
<li><p>消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</p>
</li>
</ul>
<hr>
<h3 id="2-同步发送失败策略"><a href="#2-同步发送失败策略" class="headerlink" title="2 同步发送失败策略"></a>2 同步发送失败策略</h3><p>对于普通消息，消息发送默认<strong>采用round-robin策略来选择所发送到的队列</strong>。如果发送失败，<strong>默认重试2次</strong>。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个producer，参数为Producer Group名称</span></span><br><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line"><span class="comment">// 指定nameServer地址</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 设置同步发送失败时重试发送的次数，默认为2次</span></span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 设置发送超时时限为5s，默认3s</span></span><br><span class="line">producer.setSendMsgTimeout(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>同时，Broker还具有<strong>失败隔离</strong>功能，使Producer尽量选择未发生过发送失败的Broker作为目标Broker。其可以保<strong>证其它消息尽量不发送到问题Broker</strong>，为了<strong>提升消息发送效率，降低消息发送耗时</strong>。</p>
<blockquote>
<p>思考：让我们自己实现失败隔离功能，如何来做？</p>
<p>1 ）方案一：Producer中维护某JUC的Map集合，其key是发生失败的时间戳，value为Broker实例。Producer中还维护着一个Set集合，其中存放&gt;着所有未发生发送异常的Broker实例。选择目标Broker是从该Set集合中选择的。再定义一个定时任务，定期从Map集合中将长期未发生发送异常的Broker清理出去，并添加到Set集合。</p>
<p>2 ）方案二：为Producer中的Broker实例添加一个标识，例如是一个AtomicBoolean属性。只要该Broker上发生过发送异常，就将其置为true。选择目标Broker就是选择该属性值为false的Broker。再定义一个定时任务，定期将Broker的该属性置为false。</p>
<p>3 ）方案三：为Producer中的Broker实例添加一个标识，例如是一个AtomicLong属性。只要该Broker上发生过发送异常，就使其值增一。选择目标Broker就是选择该属性值最小的Broker。若该值相同，采用轮询方式选择。</p>
</blockquote>
<p>如果超过重试次数，则抛出异常，由Producer去保证消息不丢。当然当生产者出现RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。</p>
<hr>
<h3 id="3-异步发送失败策略"><a href="#3-异步发送失败策略" class="headerlink" title="3 异步发送失败策略"></a>3 异步发送失败策略</h3><p>异步发送失败重试时，异步重试不会选择其他broker，<strong>仅在同一个broker上做重试</strong>，所以该策略无法保证消息不丢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;192.168.109.101:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 指定异步发送失败后不进行重试发送</span></span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-消息刷盘失败策略"><a href="#4-消息刷盘失败策略" class="headerlink" title="4 消息刷盘失败策略"></a>4 消息刷盘失败策略</h3><p>消息刷盘超时（Master或Slave）或slave不可用（slave在做数据同步时向master返回状态不是SEND_OK）时，默认是不会将消息尝试发送到其他Broker的。不过，对于重要消息可以通过在Broker的配置文件设置<strong>retryAnotherBrokerWhenNotStoreOK</strong>属性为true来开启。</p>
<hr>
<h2 id="八、消息消费重试机制"><a href="#八、消息消费重试机制" class="headerlink" title="八、消息消费重试机制"></a>八、消息消费重试机制</h2><h3 id="1-顺序消息的消费重试"><a href="#1-顺序消息的消费重试" class="headerlink" title="1 顺序消息的消费重试"></a>1 顺序消息的消费重试</h3><p>对于顺序消息，当Consumer消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重试，直到消费成功。<strong>消费重试默认间隔时间为 1000 毫秒</strong>。重试期间应用会出现消息消费被阻塞的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为1000，其取值范围为[10,30000]</span></span><br><span class="line">consumer.setSuspendCurrentQueueTimeMillis(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-无序消息的消费重试"><a href="#2-无序消息的消费重试" class="headerlink" title="2 无序消息的消费重试"></a>2 无序消息的消费重试</h3><p>对于<strong>无序消息（普通消息、延时消息、事务消息）</strong>，当Consumer消费消息失败时，可以通过设置返回状态达到消息重试的效果。不过需要注意，无序消息的重试<strong>只对集群消费方式生效，广播消费方式不提供失败重试特性</strong>。</p>
<p><strong>即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息</strong>。</p>
<h3 id="3-消费重试次数与间隔"><a href="#3-消费重试次数与间隔" class="headerlink" title="3 消费重试次数与间隔"></a>3 消费重试次数与间隔</h3><p>对于<strong>无序消息集群消费下</strong>的重试消费，<strong>每条消息默认最多重试 16 次</strong>，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表。</p>
<table>
<thead>
<tr>
<th align="center">重试次数</th>
<th align="center">与上次重试的间隔时间</th>
<th align="center">重试次数</th>
<th align="center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10 秒</td>
<td align="center">9</td>
<td align="center">7 分钟</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">30秒</td>
<td align="center">10</td>
<td align="center">8 分钟</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 分钟</td>
<td align="center">11</td>
<td align="center">9 分钟</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2 分钟</td>
<td align="center">12</td>
<td align="center">10 分钟</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3 分钟</td>
<td align="center">13</td>
<td align="center">20 分钟</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4 分钟</td>
<td align="center">14</td>
<td align="center">30 分钟</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">5 分钟</td>
<td align="center">15</td>
<td align="center">1 小时</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">6 分钟</td>
<td align="center">16</td>
<td align="center">2 小时</td>
</tr>
</tbody></table>
<blockquote>
<p>若一条消息在一直消费失败的前提下，将会在正常消费后的第 4 小时 46 分后进行第 16 次重试。若仍然失败，则将消息投递到<strong>死信队列</strong></p>
</blockquote>
<p>修改消费重试次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改消费重试次数,默认16次</span></span><br><span class="line">consumer.setMaxReconsumeTimes(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>对于修改过的重试次数，将按照以下策略执行：</p>
<ul>
<li>若修改值小于 16 ，则按照指定间隔进行重试</li>
<li>若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时</li>
</ul>
<p>对于Consumer Group，若仅修改了一个Consumer的消费重试次数，则会应用到该Group中所有其它Consumer实例。若出现多个Consumer均做了修改的情况，则<strong>采用覆盖方式生效</strong>。即最后被修改的值会覆盖前面设置的值。</p>
<hr>
<h3 id="4-重试队列"><a href="#4-重试队列" class="headerlink" title="4 重试队列"></a>4 重试队列</h3><p>对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。</p>
<p>当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为**%RETRY%consumerGroup@consumerGroup**的重试队列。</p>
<blockquote>
<p>1 ）这个<strong>重试队列是针对消息才组</strong>的，而<strong>不是针对每个Topic设置的</strong>（一个Topic的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br>2 ）<strong>只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</strong><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ69.png" alt="分布式消息队列RocketMQ69.png"></p>
</blockquote>
<blockquote>
<p>注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间外，其它的时间都是相同的</p>
</blockquote>
<p>Broker对于重试消息的处理是通过<strong>延时消息</strong>实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。</p>
<hr>
<h3 id="5-消费重试配置方式"><a href="#5-消费重试配置方式" class="headerlink" title="5 消费重试配置方式"></a>5 消费重试配置方式</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ70.png" alt="分布式消息队列RocketMQ70.png"></p>
<p>集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三种方式之一的配置：</p>
<blockquote>
<p>方式 1 ：<strong>返回ConsumeConcurrentlyStatus.RECONSUME_LATER</strong>（推荐）<br>方式 2 ：返回Null<br>方式 3 ：抛出异常</p>
</blockquote>
<h3 id="6-消费不重试配置方式"><a href="#6-消费不重试配置方式" class="headerlink" title="6 消费不重试配置方式"></a>6 消费不重试配置方式</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RocketMQ71.png" alt="分布式消息队列RocketMQ71.png"></p>
<p><strong>集群消费方式</strong>下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相同的结果，即<strong>ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试</strong>。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/RocketMQ/466098e04be94025bc9cb6f501c8d6a6.png" alt="466098e04be94025bc9cb6f501c8d6a6.png"></p>
<hr>
<h2 id="九、死信队列"><a href="#九、死信队列" class="headerlink" title="九、死信队列"></a>九、死信队列</h2><h3 id="1-什么是死信队列"><a href="#1-什么是死信队列" class="headerlink" title="1 什么是死信队列"></a>1 什么是死信队列</h3><p>当一条消息初次消费失败，消息队列会自动进行消费重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是<strong>死信队列</strong>（Dead-Letter Queue，DLQ），而其中的消息则称为死信消息（Dead-Letter Message，DLM）。</p>
<blockquote>
<p>死信队列是用于处理无法被正常消费的消息的。</p>
</blockquote>
<h3 id="2-死信队列的特征"><a href="#2-死信队列的特征" class="headerlink" title="2 死信队列的特征"></a>2 死信队列的特征</h3><ul>
<li>死信队列具有如下特征：</li>
<li>死信队列中的消息不会再被消费者正常消费，即<strong>DLQ对于消费者是不可见的</strong></li>
<li>死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间）， <strong>3 天后会被自动删除</strong></li>
<li>死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup，即<strong>每个消费者组都有一个死信队列</strong></li>
<li><strong>如果一个消费者组未产生死信消息，则不会为其创建相应的死信队列</strong></li>
</ul>
<hr>
<h3 id="3-死信消息的处理"><a href="#3-死信消息的处理" class="headerlink" title="3 死信消息的处理"></a>3 死信消息的处理</h3><p>实际上，当一条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中<strong>原本就存在Bug</strong>。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">JiyCXX</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jiycxx.github.io/2019/01/18/RocketMQ4/">https://jiycxx.github.io/2019/01/18/RocketMQ4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JiyCXX.github.io" target="_blank">JiyCXX</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/RocketMQ/">RocketMQ</a><a class="post-meta__tags" href="/tags/MQ/">MQ</a></div><div class="post_share"><div class="social-share" data-image="/img/background/RocketMQ.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2019/01/16/RocketMQ3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/RocketMQ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RocketMQ 工作原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/01/14/RocketMQ/" title="RocketMQ 概述 安装 启动"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/RocketMQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-14</div><div class="title">RocketMQ 概述 安装 启动</div></div></a></div><div><a href="/2019/01/15/RocketMQ2/" title="RocketMQ 集群 理论  搭建"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/RocketMQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-15</div><div class="title">RocketMQ 集群 理论  搭建</div></div></a></div><div><a href="/2019/01/16/RocketMQ3/" title="RocketMQ 工作原理"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/RocketMQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-16</div><div class="title">RocketMQ 工作原理</div></div></a></div><div><a href="/2018/12/10/MySql/" title="MySql 基本select语句 学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/mysql.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-12-10</div><div class="title">MySql 基本select语句 学习笔记</div></div></a></div><div><a href="/2018/12/19/MySql10/" title="MySql MySQL数据类型精讲 学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/mysql.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-12-19</div><div class="title">MySql MySQL数据类型精讲 学习笔记</div></div></a></div><div><a href="/2018/12/22/MySql12/" title="MySql 视图 学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/mysql.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-12-22</div><div class="title">MySql 视图 学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JiyCXX</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JiyCXX"><i class="fab fa-github"></i><span>万物可爱</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://JiyCXX.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=289740258website=www.oicqzone.com" target="_blank" title=""><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:289740258@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-RocketMQ%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">第 4 章 RocketMQ应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-number">2.</span> <span class="toc-text">一、普通消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">1 消息发送分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">3.</span> <span class="toc-text">二、顺序消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">3.1.</span> <span class="toc-text">1 什么是顺序消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">3.2.</span> <span class="toc-text">2 为什么需要顺序消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">3 有序性分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.4.</span> <span class="toc-text">4 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">4.</span> <span class="toc-text">三、延时消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">4.1.</span> <span class="toc-text">1 什么是延时消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BB%B6%E6%97%B6%E7%AD%89%E7%BA%A7"><span class="toc-number">4.2.</span> <span class="toc-text">2 延时等级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">3 延时消息实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B-1"><span class="toc-number">4.4.</span> <span class="toc-text">4 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">5.</span> <span class="toc-text">四、事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">5.1.</span> <span class="toc-text">1 问题引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.</span> <span class="toc-text">2 解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80"><span class="toc-number">5.3.</span> <span class="toc-text">3 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-XA%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%89%91%E5%AE%A2"><span class="toc-number">5.4.</span> <span class="toc-text">4 XA模式三剑客</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-XA%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">5.5.</span> <span class="toc-text">5 XA模式架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B3%A8%E6%84%8F"><span class="toc-number">5.6.</span> <span class="toc-text">6 注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.7.</span> <span class="toc-text">7 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="toc-number">6.</span> <span class="toc-text">五、批量消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">6.1.</span> <span class="toc-text">1 批量发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%B9%E9%87%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">6.2.</span> <span class="toc-text">2 批量消费消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">3 代码举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">6.3.1.</span> <span class="toc-text">定义批量消息生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">6.3.2.</span> <span class="toc-text">定义批量消息消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">六、消息过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Tag%E8%BF%87%E6%BB%A4"><span class="toc-number">7.1.</span> <span class="toc-text">1 Tag过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SQL%E8%BF%87%E6%BB%A4"><span class="toc-number">7.2.</span> <span class="toc-text">2 SQL过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B-1"><span class="toc-number">7.3.</span> <span class="toc-text">3 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">七、消息发送重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E"><span class="toc-number">8.1.</span> <span class="toc-text">1 说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">8.2.</span> <span class="toc-text">2 同步发送失败策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">8.3.</span> <span class="toc-text">3 异步发送失败策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">8.4.</span> <span class="toc-text">4 消息刷盘失败策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">八、消息消费重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">9.1.</span> <span class="toc-text">1 顺序消息的消费重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A0%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">9.2.</span> <span class="toc-text">2 无序消息的消费重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E4%B8%8E%E9%97%B4%E9%9A%94"><span class="toc-number">9.3.</span> <span class="toc-text">3 消费重试次数与间隔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97"><span class="toc-number">9.4.</span> <span class="toc-text">4 重试队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">9.5.</span> <span class="toc-text">5 消费重试配置方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B6%88%E8%B4%B9%E4%B8%8D%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">9.6.</span> <span class="toc-text">6 消费不重试配置方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">九、死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">10.1.</span> <span class="toc-text">1 什么是死信队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">10.2.</span> <span class="toc-text">2 死信队列的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%BB%E4%BF%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">3 死信消息的处理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2019/01/18/RocketMQ4/" title="RocketMQ 应用"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/RocketMQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ 应用"/></a><div class="content"><a class="title" href="/2019/01/18/RocketMQ4/" title="RocketMQ 应用">RocketMQ 应用</a><time datetime="2019-01-18T06:00:00.000Z" title="发表于 2019-01-18 14:00:00">2019-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2019/01/16/RocketMQ3/" title="RocketMQ 工作原理"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/RocketMQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ 工作原理"/></a><div class="content"><a class="title" href="/2019/01/16/RocketMQ3/" title="RocketMQ 工作原理">RocketMQ 工作原理</a><time datetime="2019-01-16T06:00:00.000Z" title="发表于 2019-01-16 14:00:00">2019-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2019/01/15/RocketMQ2/" title="RocketMQ 集群 理论  搭建"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/RocketMQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ 集群 理论  搭建"/></a><div class="content"><a class="title" href="/2019/01/15/RocketMQ2/" title="RocketMQ 集群 理论  搭建">RocketMQ 集群 理论  搭建</a><time datetime="2019-01-15T12:00:00.000Z" title="发表于 2019-01-15 20:00:00">2019-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2019/01/14/RocketMQ/" title="RocketMQ 概述 安装 启动"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/RocketMQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ 概述 安装 启动"/></a><div class="content"><a class="title" href="/2019/01/14/RocketMQ/" title="RocketMQ 概述 安装 启动">RocketMQ 概述 安装 启动</a><time datetime="2019-01-14T12:00:00.000Z" title="发表于 2019-01-14 20:00:00">2019-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/12/27/MySql16/" title="MySql MySQL8其它新特性 学习笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/background/mysql.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySql MySQL8其它新特性 学习笔记"/></a><div class="content"><a class="title" href="/2018/12/27/MySql16/" title="MySql MySQL8其它新特性 学习笔记">MySql MySQL8其它新特性 学习笔记</a><time datetime="2018-12-27T05:45:30.000Z" title="发表于 2018-12-27 13:45:30">2018-12-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2022 By JiyCXX</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://JiyCXX.github.io"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script type="text/javascript" src="/js/custom.js"></script><script type="text/javascript" src="/js/custom.css"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.16/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?JiyCXX";
            var git_color =['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'];
            var git_user ="JiyCXX";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style>undefined</style><!-- hexo injector body_end end --></body></html>